// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components.proto

#ifndef PROTOBUF_components_2eproto__INCLUDED
#define PROTOBUF_components_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace tec {
namespace proto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_components_2eproto();
void protobuf_AssignDesc_components_2eproto();
void protobuf_ShutdownFile_components_2eproto();

class Renderable;
class Position;
class Orientation;
class Component;
class Entity;
class EntityList;

// ===================================================================

class Renderable : public ::google::protobuf::Message {
 public:
  Renderable();
  virtual ~Renderable();

  Renderable(const Renderable& from);

  inline Renderable& operator=(const Renderable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Renderable& default_instance();

  void Swap(Renderable* other);

  // implements Message ----------------------------------------------

  inline Renderable* New() const { return New(NULL); }

  Renderable* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Renderable& from);
  void MergeFrom(const Renderable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Renderable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string shader_name = 1;
  bool has_shader_name() const;
  void clear_shader_name();
  static const int kShaderNameFieldNumber = 1;
  const ::std::string& shader_name() const;
  void set_shader_name(const ::std::string& value);
  void set_shader_name(const char* value);
  void set_shader_name(const char* value, size_t size);
  ::std::string* mutable_shader_name();
  ::std::string* release_shader_name();
  void set_allocated_shader_name(::std::string* shader_name);

  // optional string mesh_name = 2;
  bool has_mesh_name() const;
  void clear_mesh_name();
  static const int kMeshNameFieldNumber = 2;
  const ::std::string& mesh_name() const;
  void set_mesh_name(const ::std::string& value);
  void set_mesh_name(const char* value);
  void set_mesh_name(const char* value, size_t size);
  ::std::string* mutable_mesh_name();
  ::std::string* release_mesh_name();
  void set_allocated_mesh_name(::std::string* mesh_name);

  // optional bool hidden = 3;
  bool has_hidden() const;
  void clear_hidden();
  static const int kHiddenFieldNumber = 3;
  bool hidden() const;
  void set_hidden(bool value);

  // @@protoc_insertion_point(class_scope:tec.proto.Renderable)
 private:
  inline void set_has_shader_name();
  inline void clear_has_shader_name();
  inline void set_has_mesh_name();
  inline void clear_has_mesh_name();
  inline void set_has_hidden();
  inline void clear_has_hidden();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr shader_name_;
  ::google::protobuf::internal::ArenaStringPtr mesh_name_;
  bool hidden_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Renderable* default_instance_;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::Message {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  void Swap(Position* other);

  // implements Message ----------------------------------------------

  inline Position* New() const { return New(NULL); }

  Position* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:tec.proto.Position)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class Orientation : public ::google::protobuf::Message {
 public:
  Orientation();
  virtual ~Orientation();

  Orientation(const Orientation& from);

  inline Orientation& operator=(const Orientation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Orientation& default_instance();

  void Swap(Orientation* other);

  // implements Message ----------------------------------------------

  inline Orientation* New() const { return New(NULL); }

  Orientation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Orientation& from);
  void MergeFrom(const Orientation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Orientation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // required float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // required float w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  float w() const;
  void set_w(float value);

  // @@protoc_insertion_point(class_scope:tec.proto.Orientation)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_w();
  inline void clear_has_w();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  float w_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Orientation* default_instance_;
};
// -------------------------------------------------------------------

class Component : public ::google::protobuf::Message {
 public:
  Component();
  virtual ~Component();

  Component(const Component& from);

  inline Component& operator=(const Component& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Component& default_instance();

  enum ComponentCase {
    kRenderable = 1,
    kPosition = 2,
    kOrientation = 3,
    COMPONENT_NOT_SET = 0,
  };

  void Swap(Component* other);

  // implements Message ----------------------------------------------

  inline Component* New() const { return New(NULL); }

  Component* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Component& from);
  void MergeFrom(const Component& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Component* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .tec.proto.Renderable renderable = 1;
  bool has_renderable() const;
  void clear_renderable();
  static const int kRenderableFieldNumber = 1;
  const ::tec::proto::Renderable& renderable() const;
  ::tec::proto::Renderable* mutable_renderable();
  ::tec::proto::Renderable* release_renderable();
  void set_allocated_renderable(::tec::proto::Renderable* renderable);

  // optional .tec.proto.Position position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  const ::tec::proto::Position& position() const;
  ::tec::proto::Position* mutable_position();
  ::tec::proto::Position* release_position();
  void set_allocated_position(::tec::proto::Position* position);

  // optional .tec.proto.Orientation orientation = 3;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 3;
  const ::tec::proto::Orientation& orientation() const;
  ::tec::proto::Orientation* mutable_orientation();
  ::tec::proto::Orientation* release_orientation();
  void set_allocated_orientation(::tec::proto::Orientation* orientation);

  ComponentCase component_case() const;
  // @@protoc_insertion_point(class_scope:tec.proto.Component)
 private:
  inline void set_has_renderable();
  inline void set_has_position();
  inline void set_has_orientation();

  inline bool has_component() const;
  void clear_component();
  inline void clear_has_component();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union ComponentUnion {
    ComponentUnion() {}
    ::tec::proto::Renderable* renderable_;
    ::tec::proto::Position* position_;
    ::tec::proto::Orientation* orientation_;
  } component_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Component* default_instance_;
};
// -------------------------------------------------------------------

class Entity : public ::google::protobuf::Message {
 public:
  Entity();
  virtual ~Entity();

  Entity(const Entity& from);

  inline Entity& operator=(const Entity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Entity& default_instance();

  void Swap(Entity* other);

  // implements Message ----------------------------------------------

  inline Entity* New() const { return New(NULL); }

  Entity* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Entity& from);
  void MergeFrom(const Entity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Entity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // repeated .tec.proto.Component components = 2;
  int components_size() const;
  void clear_components();
  static const int kComponentsFieldNumber = 2;
  const ::tec::proto::Component& components(int index) const;
  ::tec::proto::Component* mutable_components(int index);
  ::tec::proto::Component* add_components();
  const ::google::protobuf::RepeatedPtrField< ::tec::proto::Component >&
      components() const;
  ::google::protobuf::RepeatedPtrField< ::tec::proto::Component >*
      mutable_components();

  // @@protoc_insertion_point(class_scope:tec.proto.Entity)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::RepeatedPtrField< ::tec::proto::Component > components_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Entity* default_instance_;
};
// -------------------------------------------------------------------

class EntityList : public ::google::protobuf::Message {
 public:
  EntityList();
  virtual ~EntityList();

  EntityList(const EntityList& from);

  inline EntityList& operator=(const EntityList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityList& default_instance();

  void Swap(EntityList* other);

  // implements Message ----------------------------------------------

  inline EntityList* New() const { return New(NULL); }

  EntityList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntityList& from);
  void MergeFrom(const EntityList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EntityList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tec.proto.Entity entities = 1;
  int entities_size() const;
  void clear_entities();
  static const int kEntitiesFieldNumber = 1;
  const ::tec::proto::Entity& entities(int index) const;
  ::tec::proto::Entity* mutable_entities(int index);
  ::tec::proto::Entity* add_entities();
  const ::google::protobuf::RepeatedPtrField< ::tec::proto::Entity >&
      entities() const;
  ::google::protobuf::RepeatedPtrField< ::tec::proto::Entity >*
      mutable_entities();

  // @@protoc_insertion_point(class_scope:tec.proto.EntityList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tec::proto::Entity > entities_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static EntityList* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Renderable

// optional string shader_name = 1;
inline bool Renderable::has_shader_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Renderable::set_has_shader_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Renderable::clear_has_shader_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Renderable::clear_shader_name() {
  shader_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_shader_name();
}
inline const ::std::string& Renderable::shader_name() const {
  // @@protoc_insertion_point(field_get:tec.proto.Renderable.shader_name)
  return shader_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Renderable::set_shader_name(const ::std::string& value) {
  set_has_shader_name();
  shader_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tec.proto.Renderable.shader_name)
}
inline void Renderable::set_shader_name(const char* value) {
  set_has_shader_name();
  shader_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tec.proto.Renderable.shader_name)
}
inline void Renderable::set_shader_name(const char* value, size_t size) {
  set_has_shader_name();
  shader_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tec.proto.Renderable.shader_name)
}
inline ::std::string* Renderable::mutable_shader_name() {
  set_has_shader_name();
  // @@protoc_insertion_point(field_mutable:tec.proto.Renderable.shader_name)
  return shader_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Renderable::release_shader_name() {
  clear_has_shader_name();
  return shader_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Renderable::set_allocated_shader_name(::std::string* shader_name) {
  if (shader_name != NULL) {
    set_has_shader_name();
  } else {
    clear_has_shader_name();
  }
  shader_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), shader_name);
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Renderable.shader_name)
}

// optional string mesh_name = 2;
inline bool Renderable::has_mesh_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Renderable::set_has_mesh_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Renderable::clear_has_mesh_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Renderable::clear_mesh_name() {
  mesh_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mesh_name();
}
inline const ::std::string& Renderable::mesh_name() const {
  // @@protoc_insertion_point(field_get:tec.proto.Renderable.mesh_name)
  return mesh_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Renderable::set_mesh_name(const ::std::string& value) {
  set_has_mesh_name();
  mesh_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tec.proto.Renderable.mesh_name)
}
inline void Renderable::set_mesh_name(const char* value) {
  set_has_mesh_name();
  mesh_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tec.proto.Renderable.mesh_name)
}
inline void Renderable::set_mesh_name(const char* value, size_t size) {
  set_has_mesh_name();
  mesh_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tec.proto.Renderable.mesh_name)
}
inline ::std::string* Renderable::mutable_mesh_name() {
  set_has_mesh_name();
  // @@protoc_insertion_point(field_mutable:tec.proto.Renderable.mesh_name)
  return mesh_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Renderable::release_mesh_name() {
  clear_has_mesh_name();
  return mesh_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Renderable::set_allocated_mesh_name(::std::string* mesh_name) {
  if (mesh_name != NULL) {
    set_has_mesh_name();
  } else {
    clear_has_mesh_name();
  }
  mesh_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mesh_name);
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Renderable.mesh_name)
}

// optional bool hidden = 3;
inline bool Renderable::has_hidden() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Renderable::set_has_hidden() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Renderable::clear_has_hidden() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Renderable::clear_hidden() {
  hidden_ = false;
  clear_has_hidden();
}
inline bool Renderable::hidden() const {
  // @@protoc_insertion_point(field_get:tec.proto.Renderable.hidden)
  return hidden_;
}
inline void Renderable::set_hidden(bool value) {
  set_has_hidden();
  hidden_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Renderable.hidden)
}

// -------------------------------------------------------------------

// Position

// optional float x = 1;
inline bool Position::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Position::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Position::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Position::x() const {
  // @@protoc_insertion_point(field_get:tec.proto.Position.x)
  return x_;
}
inline void Position::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Position.x)
}

// optional float y = 2;
inline bool Position::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Position::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Position::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Position::y() const {
  // @@protoc_insertion_point(field_get:tec.proto.Position.y)
  return y_;
}
inline void Position::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Position.y)
}

// optional float z = 3;
inline bool Position::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Position::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Position::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Position::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Position::z() const {
  // @@protoc_insertion_point(field_get:tec.proto.Position.z)
  return z_;
}
inline void Position::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Position.z)
}

// -------------------------------------------------------------------

// Orientation

// required float x = 1;
inline bool Orientation::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Orientation::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Orientation::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Orientation::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Orientation::x() const {
  // @@protoc_insertion_point(field_get:tec.proto.Orientation.x)
  return x_;
}
inline void Orientation::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Orientation.x)
}

// required float y = 2;
inline bool Orientation::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Orientation::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Orientation::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Orientation::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Orientation::y() const {
  // @@protoc_insertion_point(field_get:tec.proto.Orientation.y)
  return y_;
}
inline void Orientation::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Orientation.y)
}

// required float z = 3;
inline bool Orientation::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Orientation::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Orientation::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Orientation::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Orientation::z() const {
  // @@protoc_insertion_point(field_get:tec.proto.Orientation.z)
  return z_;
}
inline void Orientation::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Orientation.z)
}

// required float w = 4;
inline bool Orientation::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Orientation::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Orientation::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Orientation::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline float Orientation::w() const {
  // @@protoc_insertion_point(field_get:tec.proto.Orientation.w)
  return w_;
}
inline void Orientation::set_w(float value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Orientation.w)
}

// -------------------------------------------------------------------

// Component

// optional .tec.proto.Renderable renderable = 1;
inline bool Component::has_renderable() const {
  return component_case() == kRenderable;
}
inline void Component::set_has_renderable() {
  _oneof_case_[0] = kRenderable;
}
inline void Component::clear_renderable() {
  if (has_renderable()) {
    delete component_.renderable_;
    clear_has_component();
  }
}
inline const ::tec::proto::Renderable& Component::renderable() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.renderable)
  return has_renderable() ? *component_.renderable_
                      : ::tec::proto::Renderable::default_instance();
}
inline ::tec::proto::Renderable* Component::mutable_renderable() {
  if (!has_renderable()) {
    clear_component();
    set_has_renderable();
    component_.renderable_ = new ::tec::proto::Renderable;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.renderable)
  return component_.renderable_;
}
inline ::tec::proto::Renderable* Component::release_renderable() {
  if (has_renderable()) {
    clear_has_component();
    ::tec::proto::Renderable* temp = component_.renderable_;
    component_.renderable_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_renderable(::tec::proto::Renderable* renderable) {
  clear_component();
  if (renderable) {
    set_has_renderable();
    component_.renderable_ = renderable;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.renderable)
}

// optional .tec.proto.Position position = 2;
inline bool Component::has_position() const {
  return component_case() == kPosition;
}
inline void Component::set_has_position() {
  _oneof_case_[0] = kPosition;
}
inline void Component::clear_position() {
  if (has_position()) {
    delete component_.position_;
    clear_has_component();
  }
}
inline const ::tec::proto::Position& Component::position() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.position)
  return has_position() ? *component_.position_
                      : ::tec::proto::Position::default_instance();
}
inline ::tec::proto::Position* Component::mutable_position() {
  if (!has_position()) {
    clear_component();
    set_has_position();
    component_.position_ = new ::tec::proto::Position;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.position)
  return component_.position_;
}
inline ::tec::proto::Position* Component::release_position() {
  if (has_position()) {
    clear_has_component();
    ::tec::proto::Position* temp = component_.position_;
    component_.position_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_position(::tec::proto::Position* position) {
  clear_component();
  if (position) {
    set_has_position();
    component_.position_ = position;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.position)
}

// optional .tec.proto.Orientation orientation = 3;
inline bool Component::has_orientation() const {
  return component_case() == kOrientation;
}
inline void Component::set_has_orientation() {
  _oneof_case_[0] = kOrientation;
}
inline void Component::clear_orientation() {
  if (has_orientation()) {
    delete component_.orientation_;
    clear_has_component();
  }
}
inline const ::tec::proto::Orientation& Component::orientation() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.orientation)
  return has_orientation() ? *component_.orientation_
                      : ::tec::proto::Orientation::default_instance();
}
inline ::tec::proto::Orientation* Component::mutable_orientation() {
  if (!has_orientation()) {
    clear_component();
    set_has_orientation();
    component_.orientation_ = new ::tec::proto::Orientation;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.orientation)
  return component_.orientation_;
}
inline ::tec::proto::Orientation* Component::release_orientation() {
  if (has_orientation()) {
    clear_has_component();
    ::tec::proto::Orientation* temp = component_.orientation_;
    component_.orientation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_orientation(::tec::proto::Orientation* orientation) {
  clear_component();
  if (orientation) {
    set_has_orientation();
    component_.orientation_ = orientation;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.orientation)
}

inline bool Component::has_component() const {
  return component_case() != COMPONENT_NOT_SET;
}
inline void Component::clear_has_component() {
  _oneof_case_[0] = COMPONENT_NOT_SET;
}
inline Component::ComponentCase Component::component_case() const {
  return Component::ComponentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Entity

// required uint64 id = 1;
inline bool Entity::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Entity::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Entity::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Entity::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Entity::id() const {
  // @@protoc_insertion_point(field_get:tec.proto.Entity.id)
  return id_;
}
inline void Entity::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Entity.id)
}

// repeated .tec.proto.Component components = 2;
inline int Entity::components_size() const {
  return components_.size();
}
inline void Entity::clear_components() {
  components_.Clear();
}
inline const ::tec::proto::Component& Entity::components(int index) const {
  // @@protoc_insertion_point(field_get:tec.proto.Entity.components)
  return components_.Get(index);
}
inline ::tec::proto::Component* Entity::mutable_components(int index) {
  // @@protoc_insertion_point(field_mutable:tec.proto.Entity.components)
  return components_.Mutable(index);
}
inline ::tec::proto::Component* Entity::add_components() {
  // @@protoc_insertion_point(field_add:tec.proto.Entity.components)
  return components_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tec::proto::Component >&
Entity::components() const {
  // @@protoc_insertion_point(field_list:tec.proto.Entity.components)
  return components_;
}
inline ::google::protobuf::RepeatedPtrField< ::tec::proto::Component >*
Entity::mutable_components() {
  // @@protoc_insertion_point(field_mutable_list:tec.proto.Entity.components)
  return &components_;
}

// -------------------------------------------------------------------

// EntityList

// repeated .tec.proto.Entity entities = 1;
inline int EntityList::entities_size() const {
  return entities_.size();
}
inline void EntityList::clear_entities() {
  entities_.Clear();
}
inline const ::tec::proto::Entity& EntityList::entities(int index) const {
  // @@protoc_insertion_point(field_get:tec.proto.EntityList.entities)
  return entities_.Get(index);
}
inline ::tec::proto::Entity* EntityList::mutable_entities(int index) {
  // @@protoc_insertion_point(field_mutable:tec.proto.EntityList.entities)
  return entities_.Mutable(index);
}
inline ::tec::proto::Entity* EntityList::add_entities() {
  // @@protoc_insertion_point(field_add:tec.proto.EntityList.entities)
  return entities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tec::proto::Entity >&
EntityList::entities() const {
  // @@protoc_insertion_point(field_list:tec.proto.EntityList.entities)
  return entities_;
}
inline ::google::protobuf::RepeatedPtrField< ::tec::proto::Entity >*
EntityList::mutable_entities() {
  // @@protoc_insertion_point(field_mutable_list:tec.proto.EntityList.entities)
  return &entities_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace tec

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_components_2eproto__INCLUDED
